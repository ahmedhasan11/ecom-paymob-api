أولًا: خلاصة IEquatable<Money> ------->"يا C#، أنا عندي مقارنة متخصصة بين Money وMoney."

هو ببساطة:

وسيلة تخلي C# يعرف يقارن بين 2 Money بطريقة محترمة (بالقيمة مش بالمكان في الذاكرة).

وده المطلوب لأي Value Object.
من غيره → C# هيستخدم مقارنة “Object” العامة، اللي مش مناسبة للـ Value Objects.



sealed-->ممنوع حد يرث (extends) منه. ده مهم للـ Value Object عشان نمنع تغيّرات غير متوقعة عن طريق الوراثة.


🎯 ثانيًا: خلاصة كل الميثودز اللي في Money

إحنا عاملين 4 حاجات رئيسية:

1) From(amount)

علشان نعمل Money بشكل آمن (validation + منع negative + rounding).

2) Add(other)

علشان نعمل عملية جمع بين قيمتين مالية ونرجّع VO جديد (immutable behavior).

3) Equals(Money other)

المقارنة الأساسية اللي احنا فعليًا بنعتمد عليها.

4) override Equals(object)

دي مجرد تحوّل أي object لمقارنة Money…
زي لما حد يعمل:




		public override bool Equals(object? obj) => Equals(obj as Money); /*دي معمولة علشان:

لو حد قارن Money بـ object
C# يحوّله لـ Money وبعدين ينادي Equals(Money).

فهي مجرد كوبري.*/




IEquatable: إعلان إن عندنا مقارنة متخصصة.

Equals(Money): المقارنة الحقيقية بالقيمة.

Equals(object): بوابة لأي مقارنة جاية من object.

كلهم بيخدموا نفس الهدف:

إن 2 من Money يتقارنوا بالقيمة مش بالذاكرة.